# Greedy

탐욕법. 어떤 문제에 대해 단순 무식하게 탐욕적으로 해결하는 알고리즘이다. 여기서 탐욕적이라는 말은 '현재 상황에서 지금 당장 좋은 것만 고르는 방법'을 의미한다. 그리디 알고리즘을 이용하면 매 순간 가장 좋아 보이는 것을 선택하며, 현재의 선택이 나중에 미칠 영향에 대해서는 고려하지 않는다.

## 예제 — 거스름돈

**500원, 100원, 10원짜리 동전이 무한히 존재한다고 가정할 때 손님에게 거슬러 줘야 할 돈이 price원일 때 거슬러줘야 할 동전의 최소 개수를 구하라. 단, 거슬러 줘야 할 돈 price은 항상 10의 배수이다.**

```python
def moneyCount(price: int):
  n = price
  count = 0

  coin_types = [500, 100, 50 ,10]
  for coin in coin_types:
    count += n // coin # //: 몫
    n %= coin # %=: n/coin의 나머지를 n에 할당

  return count
  
print(moneyCount(1260)) # 6
```

화폐의 종류 개수만큼 반복을 수행하므로 화폐의 종류가 n개라고 할 때 위의 코드의 시간 복잡도는 O(n). 여기서 거슬러 줘야할 액수인 price는 위 알고리즘의 시간복잡도에 영향을 미치지 않는다.

### 그리디 알고리즘의 정당성

그리디 알고리즘으로 문제의 해법을 찾았을 때는 그 해법이 정당하지 검토해야 한다. 거스름돈 문제를 그리디 알고리즘으로 해결할 수 있는 이유는 가지고 있는 동전 중에서 큰 단위가 항상 작은 단위의 배수이므로 작은 단위의 동전들을 종합해 다른 해가 나올 수 없기 때문이다.

대부분의 그리디 알고리즘 문제에서는 이처럼 문제 풀이를 위한 최소한의 아이디어를 떠올리고 이것이 정당한지 검토할 수 있어야 답을 도출할 수 있다.

## 예제 — 큰 수의 법칙

### 문제

큰 수의 법칙은 정수로 이루어진 배열이 있을 때 주어진 수들을 M번 더하여 가장 큰 수를 만드는 법칙이다. 단, 배열의 특정한 인덱스에 해당하는 수가 연속해서 K번을 초과하여 더해질 수 없다.

**입력 조건**

- 첫째 줄에 N(2 ≤ N ≤ 1000), M(1 ≤ M ≤ 10000), K(1 ≤ K ≤ 10000)의 자연수가 주어지며, 각 자연수는 공백으로 구분한다.
- 둘째 줄에 N개의 자연수가 주어진다. 각 자연수는 공백으로 구분한다. 단, 각각의 자연수는 1이상 10000 이하의 수로 주어진다.
- 입력으로 주어지는 K는 항상 M보다 작거나 같다.

**출력 조건**

- 첫째 줄에 큰 수의 법칙에 따라 더해진 답을 출력한다.

**입력 예시**

```python
5 8 3
2 4 5 4 6
```

**출력 예시**

```python
46
```

### 해설

입력값 중에서 가장 큰 수와 두 번째로 큰 수만 저장하면 된다. 연속으로 더할 수 있는 횟수는 최대 K번이므로 '가장 큰 수를 K번 더하고 두 번째로 큰 수를 한 번 더하는 연산'을 반복하면 된다.

```python
# n m k를 공백으로 구분하여 입력받기
n, m, k = map(int, input().split())
# n개의 수를 공백으로 구분하여 입력받기
data = list(map(int, input().split()))

data.sort() # 입력받은 수들 정렬하기
first = data[n - 1] # 가장 큰 수
second = data[n - 2] # 두 번째로 큰 수

result = 0

while True:
  for i in range(k): # 가장 큰 수를 K번 더하기
    if m == 0: # m이 0이면 반복문 탈출
      break
    result += first
    m -= 1 # 더할 때마다 1씩 빼기
  if m == 0: # m이 0이면 반복문 탈출
    break
  result += second # 두 번째로 큰 수를 한 번 더하기
  m -= 1 # 더할 때마다 1씩 빼기

print(result)
```